<!DOCTYPE html>
<html>
  <head>
    <title>Quantum Computational Science</title>
    <link href="./styles/qisstyle.css" rel="stylesheet">


    <!--Geogebra Support-->
    <script src="navigation.js"></script>


    <!--MathJax Support-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>MathJax.Hub.Config({  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}},
                                  loader: {load: ['[tex]/ams']},
                                  tex: {packages: {'[+]': ['ams']}});</script>
    <meta charset="UTF-8">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Monsieur+La+Doulaise&display=swap" rel="stylesheet">

    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="./images/iconwhite/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="./images/iconwhite/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="./images/iconwhite/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="./images/iconwhite/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon-precomposed" sizes="60x60" href="./images/iconwhite/apple-touch-icon-60x60.png" />
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="./images/iconwhite/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="./images/iconwhite/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="./images/iconwhite/apple-touch-icon-152x152.png" />
    <link rel="icon" type="image/png" href="./images/iconwhite/favicon-196x196.png" sizes="196x196" />
    <link rel="icon" type="image/png" href="./images/iconwhite/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="./images/iconwhite/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="./images/iconwhite/favicon-16x16.png" sizes="16x16" />
    <link rel="icon" type="image/png" href="./images/iconwhite/favicon-128.png" sizes="128x128" />
    <meta name="application-name" content="&nbsp;"/>
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="msapplication-TileImage" content="./images/iconwhite/mstile-144x144.png" />
    <meta name="msapplication-square70x70logo" content="./images/iconwhite/mstile-70x70.png" />
    <meta name="msapplication-square150x150logo" content="./images/iconwhite/mstile-150x150.png" />
    <meta name="msapplication-wide310x150logo" content="./images/iconwhite/mstile-310x150.png" />
    <meta name="msapplication-square310x310logo" content="./images/iconwhite/mstile-310x310.png" />



    <meta charset="UTF-8">
    <meta name="description" content="Resources and discussion relevant to Quantum Computational and Informational
                                      Science. Topics include basic quantum algorithims and programming in Qiskit.">
    <meta name="keywords" content=" ">
    <meta name="author" content="Alexander J. Heilman">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="index, follow">
  </head>
  
  <body>
  <div id="home">
    <a href="https://www.alexheilman.com"><img id="homeimg" src="./images/iconwhite/favicon-196x196.png" width="50" height="auto"></a>
  </div>

      <section id="explanation">
          <h1 id="title">
            Quantum Computational Science   
          </h1>
          <p id="expp">
            Quantum computers promise new computational paradigms as hardware limitations
            decrease. Their relevance is justified rather succintly with the following statement:
            an operational quantum computer would immediatley render obsolete some
            forms of cryptography currently implemented (namely the application of Shor's Algorithim
            to the widely used RSA encryption scheme). The foray into basic quantum algorithms below focuses
	    on the current paradigm of the qubit, inspired by classical computation, but a case can be made
	    for a future of quantum computation based on the <a href="qis/qudits.html">qudit</a>.
          </p>
      </section>
  <!--    <section id="gates">
        <h2 id="gatestitle">
          Basic Quantum Gates
        </h2>
          <p>
          Quantum circuits are constructed of quantum gates. Though an infinite number of them
          is needed to really span even the space of \(2^n\) dimensional spaces (that is, the 
          state space of qubits). Some of the most common are listed and displayed below.
          </p>
        <h3 id="paulititle">
          Pauli Matrices
        </h3>
          <p>
            The most basic qubit gates are also known as and can be represented by the Pauli
            matrices, shown below.
            <div class="eq ib" id="pauli0">
              $$
              \sigma_0=\mathbb{I}=\begin{bmatrix} 1 & 0\\
                                                  0 & 1\\ \end{bmatrix} 
              $$
            </div>
            <div class="eq ib" id="pauli1">
              $$
              \sigma_1=X=\begin{bmatrix} 0 & 1\\
                                         1 & 0\\ \end{bmatrix}
              $$
            </div>
            <div class="eq ib" id="pauli2">
              $$
              \sigma_2=Y=\begin{bmatrix} 0 & i\\
                                         -i & 0\\ \end{bmatrix}
              $$
            </div>
            <div class="eq ib" id="pauli3">
              $$
              \sigma_3=Z=\begin{bmatrix} 1 &  0\\
                                         0 & -1\\ \end{bmatrix}
              $$
            </div>
          </p>
        <h3 id="Htitle">
          Hadamard Gate
        </h3>
          <p>
           <div class="eq ib" id="Hgate">
              $$
              H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 &  1\\
                                         1 & -1\\ \end{bmatrix}
              $$
            </div>
          </p>
      </section> -->
      <section id="algorithims">
          <h2 id="algorithimstitle">
            Basic Quantum Algorithims
          </h2>
            <p>
            Many algorithims use more basic algorithims as components. Arguably, the three most
            general and basic quantum algorithims are the Quantum Fourier Transform (QFT), the
            quantum algorithim for phase estimation of some unitary operatory (Phase Estimation), and
            the quantum algorithim for the amplification of some desirable subspace in some 
            larger superposition (Amplitude Amplification). These three algorithims build off of each 
            other in the order just given. That is, the QFT is the simplest, while phase estimation
            incorporates the QFT, and amplitude amplification generally requires the use of phase
            estimation. Phase estimation is the quantum machinery in Shor's algorithim.
            Amplitude amplification can be seen as a generalization of Grover's search algorithim.
            </p>


          <h3 id="qfttitle">
            Quantum Fourier Transform
          </h3>
           <div id="qftcoll">
             <p>  
               The quantum Fourier transform is a quantum implementation
               of the discrete Fourier transform. 
               Given some pure quantum state of the computational basis \(\vert j \rangle \) where \(j\) ranges from
               \(N=0\) to \(2^n-1\), the \(n\)-qubit QFT acts on \(\vert j \rangle\) as

                <div id="qfteq1" class="eq">
                  $$ \vert j  \rangle  \rightarrow \frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}e^{2\pi i j k/ N}\vert k \rangle . $$
                </div>
                <div id="qftcols1">
                  <div id="qftcols11">
                    In this way, the QFT effectively takes some computational basis state \( \vert j \rangle \) and
                    returns a complete superposition of basis states traveling around the unit circle at a 
                    rate \( \omega^j \).
                  </div>
                  <div id="qftcols12">
                    <img src="./images/qis/qftpoly.svg" alt="QFT polygon of state coefficients" id="qftpoly" height="auto" width="80%"> 
                  </div>
               </div>
               In terms of the binary computational basis, the QFT can be expanded as

                <div id="qfteq2"i class="eq">
                  $$ \vert j_1,...,j_n \rangle \rightarrow \frac{\left( \vert 0 \rangle  + e^{2\pi i0.j_n} \vert 1 \rangle  \right)\otimes \left( \vert 0 \rangle  + e^{2\pi i0.j_{n-1}j_n} \vert 1 \rangle \right)\otimes ...\otimes \left( \vert 0 \rangle  + e^{2\pi i0.j_1...j_n}  \vert 1 \rangle  \right)  }{2^{n/2}} .$$
                </div>

                And here the binary representation of decimals is used so that \( 0.j_1j_2...j_n=\frac{j_1}
                {2}+\frac{j_2}{4}+...+\frac{j_n}{2^n}\) where all \( j_i=0 \) or 1.

                The QFT, like any strictly quantum operation, is really a unitary operator. 
		


<br>

            	<button type="button" class="collapsible">3-Qubit QFT Example</button>
		<div class="content">
 		  As an example, 
                  here is the matrix form of the 3-qubit QFT:

                  <div id="3QFTmat" class="eq">
                    $$  
                    \frac{1}{2\sqrt{2}} 
                    \begin{bmatrix}
                    1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\
                    1 & \omega &\omega ^2      &\omega ^3  &\omega ^{4} &\omega ^{5} &\omega ^{6} &\omega ^{7}\\
                    1 & \omega ^2&\omega ^{4}  &\omega^{6} &1       &\omega ^2&\omega ^{4} &\omega ^{6}\\
                    1 &\omega ^{3}&\omega ^{6} &\omega     &\omega ^{4} &\omega ^{7} &\omega ^2&\omega ^{5} \\
                    1 &\omega ^{4}&           1&\omega^{4} &1&\omega ^{4} &1 & \omega ^{4}   \\
                    1 &\omega ^{5}&\omega ^{2} &\omega^{7} &\omega ^{4} &\omega &\omega ^6&\omega ^{3} \\
                    1 &\omega ^{6}&\omega ^{4} &\omega^2  &1&\omega ^{6} &\omega ^4&\omega ^{2} \\
                    1 &\omega ^{7}&\omega ^{6} &\omega^{5}  &\omega ^{4} &\omega ^{3} &\omega ^2&\omega  \\
                    \end{bmatrix}
                    $$
                  </div>
                  And below is the corresponding quantum circuit for the 3-qubit QFT (without swaps):
                  <br>
                  <a class="center" href="https://commons.wikimedia.org/wiki/File:Quantum_Fourier_transform_on_three_qubits.svg" target="_blank">
                    <img id="QFT3qbcircuit" src="./images/3qubitQFTwhite.svg"   alt="3-qubit QFT circuit" height="auto" width="85%" >
                  </a>
		</div>

                <br>

                <div class="margin5">
                The QFT is a wonderful little routine, that would expedite many classical
                processes' if only we had direct access to the output state vector.
                However, one of the great uses of the QFT in quantum speed-ups is it's
                close association to phase estimation, a truly useful template for 
                quantum circuits. For a deeper look at the Quantum Fourier Transform, see notes by
                <a href="https://viterbi-web.usc.edu/~tbrun/Course/lecture13.pdf">
                  Todd Brun
                </a>,
		<a href="https://courses.cs.washington.edu/courses/cse599d/06wi/lecturenotes9.pdf">
	          Dave Bacon
		</a>,
		and
                <a href="https://www.scottaaronson.com/qclec/20.pdf">
		  Scott Aaronson</a> or Chapter 5 ("The quantum Fourier transform and it's applications") of 
                  <a href="http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf#page=244">
                  Nielsen and Chuang</a>.
		</div>
              </p>
            </div>

<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>
            <div id="qftcol2">
               
            </div>

          <h3 id="petitle">
            Phase Estimation
          </h3>
          <p id="peintro">
            The quantum phase estimation algorithim computes the eigenvalue of some
            unitary operator given an associated eigenvector. The name phase estimation comes
            from the fact that the eigenvalues of a unitary operator are neccessarily of
            norm one and thus have the form \( \lambda = e^{\theta i} \), so
            finding the phase \( \theta \) is equivalent to calculating the eigenvalue.
          </p>
          <p id="pe2">
          <div class="center">
            <a class= href="https://commons.wikimedia.org/wiki/File:PhaseCircuit-crop.svg" target="_blank">
              <img id="PEnqbcircuit" src="./images/qis/nqubitpemu3.svg" alt="N-qubit phase estimation circuit diagram." height="auto" width="95%" ></a>
            </p>
          </div>
          <p id-"pe3">
            For an n-qubit phase estimation setup, any phase \( \theta=k\frac{2\pi}{2^n} \) with k an 
            integer can be deduced exactly. That is, any phase that can be encoded perfectly on
            n bits will be encoded as exactly the quanum state \( \vert k \rangle \). For phases not
            of the form \( \frac{\pi k}{2^{n-1}} \), a superposition
            of states will be produced. However, this superposition can be considered to be 'centered'
            around the real value. Upon a set of measurements, the best n-bit approximation of \( k \) will
            be measured with at least a probability ~40%.
          </p>
          <p id="pe4">
            The phase estimation algorithim is a relatively efficient way
            of calculating the eigenvalues given pairs of unitary operators and 
            associated eigenvectors. This means, for those searching for applications,
            all you have to do is reduce whatever mathematical problem you're trying to
            solve into a unitary matrix and an associated eigenvector, and consider how 
            one could encode the answer in the corresponding eigenvalue.
          </p>
          <p id="pe5">
            To see phase estimation in simulated action, see the examples in <a href="https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html">this section</a> 
            of the Qiskit textbook. For greater depth, see Section 5.2 ("Phase estimation") of <a href="http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf#page=249">
            Nielsen and Chuang</a>, lecture notes by <a href="https://inst.eecs.berkeley.edu/~cs191/fa05/lectures/lecture20_fa05.pdf">Birgitta Whaley</a>, a set
            prepared for the <a href="https://www.ryanlarose.com/uploads/1/1/5/8/115879647/quic03-phase-estimation.pdf">QUIC Seminar</a>, a short practical overview by
            <a href="https://courses.cs.washington.edu/courses/cse490q/20au/notes/13-notes1.pdf">Ansh Nagda</a>,
            or a presentation by <a href="https://viterbi-web.usc.edu/~tbrun/Course/lecture14.pdf">Todd Brun</a>.             
          </p>
          <h3 id="aatitle">
            Amplitude Amplification
          </h3>
          <p id="aaintro">
	    A generalization of Lov K. Grover's Algorithm detailed in 
	    <a href="https://arxiv.org/abs/quant-ph/9712011">
	      Quantum computers can search rapidly by using almost any transformation
	    </a>, the amplitude amplification algorithim reflects the statevector about the axis of the 'bad' subspace 
            once partitioned by an oracle, and then reflects about the axis of the original state vector (which is always
            \(\vert +\rangle^{\otimes n}\) in Grover's search algorithm with an 
            angle made with the 'good' subspace of \(\frac{1}{\sqrt{2^n}}\) ).
            Consecutive reflections of this nature nudge
            the statevector closer to the 'good' subspace, effectively 'searching' the space
            to produce a statevector aligned with the 'good' subspace. 
             <br>
            <img id="aavis1" src="./images/qis/psifin.svg" width="100%" height="auto">
             <br>
            Of course, the number
            of reflections requires knowledge about the angle between the initial statevector
            and the 'good' subspace. This information can be garnered from the use of the 
            amplitude estimation algorithim, a special case of phase estimation. The de facto
            resource for these algorithims is Giles Brassard and Peter H&#248;yer's 
            <a href="https://arxiv.org/abs/quant-ph/0005055">Quantum Amplitude Amplification and Estimation</a>.
          </p>
          <p id="aap2">
             Below is an interactive applet showing the first application of the oracle and Grover diffusion operator, known collectively as
             a single Grover iteration. We denote the reflection about the
             \(\mathcal{B}\) axis \(\mathcal{S_G}=\mathbb{I}-2\vert \psi \rangle \langle \psi \vert\). And we denote the reflection about the
             original state-vector \(-S_{\vert \psi \rangle}=\mathbb{I}
             -2\vert\psi\rangle\langle\psi\vert\). Note that the oracle is effectively the first reflection \(\mathcal{S_G} \), whereas the operator
             \(-\mathcal{S_{\vert \psi\rangle}} \) is the Grover diffusion operator when \(\vert \psi\rangle=\vert +\rangle ^{\otimes n}\) and there's 
             only one solution.
             Drag \( \vert\psi\rangle \) around to experiment with initial states with different proportions of solutions:
          </p>







<!--               <script type="text/javascript" src="https://www.geogebra.org/apps/deployggb.js"></script> 
               <script>
			 var parameters1 = {
	  		"appName":"graphing"
                        "width":1100,
                        "height":625,
                        "prerelease":false,
                        "showToolBar":false,
                        "borderColor":null,
                        "showMenuBar":false,
                        "showAlgebraInput":false,
                        "showResetIcon":true,
                        "enableLabelDrags":false,
                        "enableShiftDragZoom":false,
                        "enableRightClick":false,
                        "capturingThreshold":null,
                        "showToolBarHelp":false,
                        "errorDialogsActive":true,
                        "useBrowserForJS":false,
                        "material_id":"qz2yjtjg"};

                        var applet1 = new GGBApplet(parameters1, true);
                        window.onload = function() { 
					applet1.inject(applet_container1);
                                        }
	       </script>-->


	       <div class="centerframe">
	         <iframe src="https://www.geogebra.org/classic/qz2yjtjg?embed" width="800" height="600"
			 allowfullscreen style="border: 1px solid #e4e4e4;border-radius: 4px;" id="ggbGrover" frameborder="0"></iframe></div>

               <div id="ggb-element">
 	     </div> 
             <!--
             <script>  
                 var params = {"appName": "graphing", "width": 800, "height": 600, "showToolBar": false, "showAlgebraInput": false, "showMenuBar": false, "material_id":"qz2yjtjg" };
                 var applet = new GGBApplet(params, true);
                 window.addEventListener("load", function() { 
                     applet.inject('ggb-element');
                     });
             </script>
             -->







               <p id="aap3">
                 For more detail and exercises pertaining to Grover's search algorithm see 
                 chapter 6 of<a href="http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf#page=276">
                 Nielsen and Chuang</a>. Wikipedia has a nice article on the<a href="https://en.wikipedia.org/wiki/Grover%27s_algorithm#Geometric_proof_of_correctness">
                 Geometrical Interpretation of Grover's Algorithm</a> and 
                 <a href="https://en.wikipedia.org/wiki/Amplitude_amplification">Amplitude Amplification</a>.
               </p> 
               
               <h2>Quantum Counting</h2>
               <p id="qc1">
                 Quantum counting, or amplitude estimation, is the algorithm used to find the number of solutions in
                 the state \(\mathcal{S_G}\vert \psi\rangle\). That is, quantum counting is used to find
                 the number of basis states inverted by the oracle in amplitude amplification. It really is just phase estimation applied 
                 to repeated Grover iterations, as shown below.  
                 <img id="qcvis" src="./images/qis/QCwhite.svg" width="100%" height="auto">
 
               </p>   
             
             
             </section>

    <section id="code">
      <h2>Quantum Coding</h2>
      <p>
        Currently, the two most relevant software development kits for working with and simulating quantum circuits are
	those supported by organizations developing the hardware. IBM has their Qiskit SDK and their IBM
	Quantum Experience. They seem to be the most open to community involvement, both in terms of real access to quantum
	hardware (pretty much anyone can run small experiments now) and general resources. Google has their Cirq SDK
	which has some nice features (specifically the comparatively easy implementation of qudits) but they're generally
	less liberal in giving access to their real devices. For a more comprehensive list of resources see the following
	<a href="https://quantumcomputing.stackexchange.com/questions/1474/what-programming-languages-are-available-for-quantum-computers">
	  Stack Exchange discussion
	</a> or <a href="https://en.wikipedia.org/wiki/Quantum_programming">this Wikipedia list</a>.
      </p>
      <section id="qiskit">
          <h3 id="qiskittitle">
            Qiskit  
          </h3>
          <p>
            Qiskit is a python module supported by IBM that allows users to explicitly code quantum
            circuit frameworks on which simulations can be run. It also allows users to run
            quantum experiments on real quantum computers at IBM, though all the 
            limitations of modern technology apply (low qubit counts, poor fidelity gates,
            and non-negligible noise).
          </p>
          <p>
            For those first getting into the world of quantum programming with QISkit, 
            a wonderful free online textbook written as an introduction to both QIS and Qiskit 
            can be found at <a href="https://qiskit.org/textbook/ch-states/introduction.html">Qiskit textbook</a>.
            It's written in a mixture of html and jupyter notebook sections,
            allowing for a more interactive experience.
          </p>

         <!-- Test code env embed <div id="pytest">
            <iframe src="https://trinket.io/embed/python/edd948bf08" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
         </div> -->
      </section>
       <section id="cirq">
          <h3 id="cirqtitle">
            Cirq  
          </h3>
          <p>
            Cirq is a python module supported by Google	that allows users to explicitly code quantum
	    circuits as well. Unfortunately Google is less liberal in granting access to their real quantum
	    hardware, but simulations are built in.
	  </p>
	  <p>
	    One introductory resource for cirq can be found <a href="https://quantumai.google/cirq/tutorials/basics">here</a>.
	  </p>
     </section>
   </section>
     <section id="resources">
          <h2 id="resourcestitle">
            Resources
          </h2>
          <p>
            The classic reference for Quantum Information and Computational Science is the fantastic
            textbook, <em id="nielsenchuang">Quantum Computation and Quantum Information</em>, by
            Michael A. Nielsen and Isaac L. Chuang. This text is also a reasonably good
            introduction to the principles of QIS. However, if taken as a starting point 
            some familiarity with linear algebra is strongly recommended. It can be purchased
            in print, published by Cambridge University Press.
          </p>
	  <p>
	    Another introductory text for those getting into quantum computing is Eleanor G. Rieffel and 
	    Wolfgang H. Polak's <em>Quantum Computing: A Gentle Introduction</em>. This text is arguably a better pure
	    introduction to the field. It can also be found in print, published by MIT Press.
	  </p>
          <p>
            A great number of smaller articles for expository information are surely out there.
            One is <em><a href="https://arxiv.org/pdf/quant-ph/0011013.pdf">
            Basic concepts in quantum computation</a></em>. Another article 
            intended as an introduction to quantum algorithims is <em><a href="https://arxiv.org/pdf/1804.03719.pdf">
            Quantum Algorithm Implementations for Beginners</a></em>. And a set of lecture notes
            on quantum computation by Ronald de Wolf can be found 
            <a href="https://homepages.cwi.nl/~rdewolf/qcnotes.pdf">here</a>.
          </p>
          <p>
            
          </p>
          <p>
            <a href="http://twistedoakstudios.com/blog/Post2644_grovers-quantum-search-algorithm">Grover explained</a> <a href="https://algassert.com/post/1718">Shor explained</a>
          </p>
    </section>
  </body>
</html>
